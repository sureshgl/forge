`include "RAMWRAP.vh"
/* DO NOT EDIT THIS FILE
   File generated by:
	/auto/dsbu-asic/view/head/bin/vpp.pl \
	 -perl +define+output_file=cisco_generic_RAMWRAP_1R1W_FULL_512X22.v \
	/auto/dsbu-asic/view/head_dopplerds_G0165/wrappers/cisco_generic_RAMWRAP_1R1W.vs
*/
// $Id: cisco_generic_RAMWRAP_1R1W.vs,v 1.19 2014/07/18 01:59:09 anrobbin Exp $
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006, Cisco Systems, Inc.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of Cisco Systems, Inc;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of Cisco Systems, Inc.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
//////////////////////////////////////////////////////////////////////////////
//
// File          : cisco_generic_RAMWRAP_1R1W.vs
// Author        : Pete Johnson (petjohns@cisco.com)
// Description   : Generic Two Port RAM wrapper
//
//
//////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ns
`ifdef SYNTHESIS
`ifdef MANGLE
module RAMWRAP_1R1W_FULL_512X22 #(  parameter depth=512,
  parameter width=22,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);
      function integer log2;
    input [31:0] value;
    reg [31:0] v; // not reusing value because of DC warning
    begin
       v = value-1;
       for (log2=0; v>0; log2=log2+1)
         v = v>>1;
    end
      endfunction
endmodule // RAMWRAP_1R1W_FULL_512X22
`endif // MANGLE
`else // !SYNTHESIS

`ifndef MACRO_log2
`include "log2.vh"
`endif

  module RAMWRAP_1R1W_FULL_512X22 #(  parameter depth=512,
  parameter width=22,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);

   `MACRO_log2

   wire [width-1:0] DOUT_tmp;

//VCS coverage off
   initial if ($test$plusargs("MEM_ANNOUNCE")) $display("RAMWRAP_1R1W_FULL_512X22: Generic: %m");
//VCS coverage on

   RAMWRAP_1R1WAC_FULL_model
     #(.depth (512),.width (22),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH), .PIPELINE(PIPELINE) )
   behav
     ( .CLK_R (CLK_1X),
       .CLK_W (CLK_1X),
       .POWER_CTL (POWER_CTL),
       .SELN_R (SELN_R),
       .A_R (A_R),
       .SELN_W (SELN_W),
       .A_W (A_W),
       .WEN (WEN),
       .DIN (DIN),
       .DOUT (DOUT_tmp)
       );

`ifdef SYNTHESIS
`else

   function [width-1:0] ReadWord;
      input [log2(depth)-1:0] addr;
      begin
    ReadWord = behav.mem [addr];
      end
   endfunction // ReadWord

   task WriteWord;
      input [log2(depth)-1:0] addr;
      input [width-1:0]     data;
      begin
    behav.mem [addr] = data;
      end
   endtask // WriteWord

   task FillZero;
      integer i;
      begin
    for (i=0; i<512; i=i+1)
       behav.mem [i] = {width {1'b0}};
      end
   endtask // FillZero

   task FillOne;
      integer i;
      begin
    for (i=0; i<512; i=i+1)
       behav.mem [i] = {width {1'b1}};
      end
   endtask // FillOne

   task FillRandom;
      integer i;
      begin
         for (i=0; i<512; i=i+1)
      behav.mem [i] = {1 {$random}};
      end
   endtask // FillRandom

`endif // SYNTHESIS 

   generate
         if (PIPELINE == 0)
            assign DOUT = DOUT_tmp;
         else 
            RamWrapPipe #(.WIDTH(width),.PIPELINE(PIPELINE),.CORE_PIPE(0)) pipe(.clk(CLK_1X),.gaten(SELN_R),.pipein(DOUT_tmp),.pipeout(DOUT));
   endgenerate

endmodule // RAMWRAP_1R1W_FULL_512X22
`endif // !SYNTHESIS

/* DO NOT EDIT THIS FILE
   File generated by:
	/auto/dsbu-asic/view/head/bin/vpp.pl \
	 -perl +define+output_file=cisco_generic_RAMWRAP_1R1W_FULL_512X15.v \
	/auto/dsbu-asic/view/head_dopplerds_G0165/wrappers/cisco_generic_RAMWRAP_1R1W.vs
*/
// $Id: cisco_generic_RAMWRAP_1R1W.vs,v 1.19 2014/07/18 01:59:09 anrobbin Exp $
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006, Cisco Systems, Inc.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of Cisco Systems, Inc;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of Cisco Systems, Inc.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
//////////////////////////////////////////////////////////////////////////////
//
// File          : cisco_generic_RAMWRAP_1R1W.vs
// Author        : Pete Johnson (petjohns@cisco.com)
// Description   : Generic Two Port RAM wrapper
//
//
//////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ns
`ifdef SYNTHESIS
`ifdef MANGLE
module RAMWRAP_1R1W_FULL_512X15 #(  parameter depth=512,
  parameter width=15,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);
      function integer log2;
    input [31:0] value;
    reg [31:0] v; // not reusing value because of DC warning
    begin
       v = value-1;
       for (log2=0; v>0; log2=log2+1)
         v = v>>1;
    end
      endfunction
endmodule // RAMWRAP_1R1W_FULL_512X15
`endif // MANGLE
`else // !SYNTHESIS

`ifndef MACRO_log2
`include "log2.vh"
`endif

  module RAMWRAP_1R1W_FULL_512X15 #(  parameter depth=512,
  parameter width=15,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);

   `MACRO_log2

   wire [width-1:0] DOUT_tmp;

//VCS coverage off
   initial if ($test$plusargs("MEM_ANNOUNCE")) $display("RAMWRAP_1R1W_FULL_512X15: Generic: %m");
//VCS coverage on

   RAMWRAP_1R1WAC_FULL_model
     #(.depth (512),.width (15),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH), .PIPELINE(PIPELINE) )
   behav
     ( .CLK_R (CLK_1X),
       .CLK_W (CLK_1X),
       .POWER_CTL (POWER_CTL),
       .SELN_R (SELN_R),
       .A_R (A_R),
       .SELN_W (SELN_W),
       .A_W (A_W),
       .WEN (WEN),
       .DIN (DIN),
       .DOUT (DOUT_tmp)
       );

`ifdef SYNTHESIS
`else

   function [width-1:0] ReadWord;
      input [log2(depth)-1:0] addr;
      begin
    ReadWord = behav.mem [addr];
      end
   endfunction // ReadWord

   task WriteWord;
      input [log2(depth)-1:0] addr;
      input [width-1:0]     data;
      begin
    behav.mem [addr] = data;
      end
   endtask // WriteWord

   task FillZero;
      integer i;
      begin
    for (i=0; i<512; i=i+1)
       behav.mem [i] = {width {1'b0}};
      end
   endtask // FillZero

   task FillOne;
      integer i;
      begin
    for (i=0; i<512; i=i+1)
       behav.mem [i] = {width {1'b1}};
      end
   endtask // FillOne

   task FillRandom;
      integer i;
      begin
         for (i=0; i<512; i=i+1)
      behav.mem [i] = {1 {$random}};
      end
   endtask // FillRandom

`endif // SYNTHESIS 

   generate
         if (PIPELINE == 0)
            assign DOUT = DOUT_tmp;
         else 
            RamWrapPipe #(.WIDTH(width),.PIPELINE(PIPELINE),.CORE_PIPE(0)) pipe(.clk(CLK_1X),.gaten(SELN_R),.pipein(DOUT_tmp),.pipeout(DOUT));
   endgenerate

endmodule // RAMWRAP_1R1W_FULL_512X15
`endif // !SYNTHESIS

/* DO NOT EDIT THIS FILE
   File generated by:
	/auto/dsbu-asic/view/head/bin/vpp.pl \
	 -perl +define+output_file=cisco_generic_RAMWRAP_1R1W_FULL_512X579.v \
	/auto/dsbu-asic/view/head_dopplerds_G0165/wrappers/cisco_generic_RAMWRAP_1R1W.vs
*/
// $Id: cisco_generic_RAMWRAP_1R1W.vs,v 1.19 2014/07/18 01:59:09 anrobbin Exp $
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006, Cisco Systems, Inc.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of Cisco Systems, Inc;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of Cisco Systems, Inc.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
//////////////////////////////////////////////////////////////////////////////
//
// File          : cisco_generic_RAMWRAP_1R1W.vs
// Author        : Pete Johnson (petjohns@cisco.com)
// Description   : Generic Two Port RAM wrapper
//
//
//////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ns
`ifdef SYNTHESIS
`ifdef MANGLE
module RAMWRAP_1R1W_FULL_512X579 #(  parameter depth=512,
  parameter width=579,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);
      function integer log2;
    input [31:0] value;
    reg [31:0] v; // not reusing value because of DC warning
    begin
       v = value-1;
       for (log2=0; v>0; log2=log2+1)
         v = v>>1;
    end
      endfunction
endmodule // RAMWRAP_1R1W_FULL_512X579
`endif // MANGLE
`else // !SYNTHESIS

`ifndef MACRO_log2
`include "log2.vh"
`endif

  module RAMWRAP_1R1W_FULL_512X579 #(  parameter depth=512,
  parameter width=579,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);

   `MACRO_log2

   wire [width-1:0] DOUT_tmp;

//VCS coverage off
   initial if ($test$plusargs("MEM_ANNOUNCE")) $display("RAMWRAP_1R1W_FULL_512X579: Generic: %m");
//VCS coverage on

   RAMWRAP_1R1WAC_FULL_model
     #(.depth (512),.width (579),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH), .PIPELINE(PIPELINE) )
   behav
     ( .CLK_R (CLK_1X),
       .CLK_W (CLK_1X),
       .POWER_CTL (POWER_CTL),
       .SELN_R (SELN_R),
       .A_R (A_R),
       .SELN_W (SELN_W),
       .A_W (A_W),
       .WEN (WEN),
       .DIN (DIN),
       .DOUT (DOUT_tmp)
       );

`ifdef SYNTHESIS
`else

   function [width-1:0] ReadWord;
      input [log2(depth)-1:0] addr;
      begin
    ReadWord = behav.mem [addr];
      end
   endfunction // ReadWord

   task WriteWord;
      input [log2(depth)-1:0] addr;
      input [width-1:0]     data;
      begin
    behav.mem [addr] = data;
      end
   endtask // WriteWord

   task FillZero;
      integer i;
      begin
    for (i=0; i<512; i=i+1)
       behav.mem [i] = {width {1'b0}};
      end
   endtask // FillZero

   task FillOne;
      integer i;
      begin
    for (i=0; i<512; i=i+1)
       behav.mem [i] = {width {1'b1}};
      end
   endtask // FillOne

   task FillRandom;
      integer i;
      begin
         for (i=0; i<512; i=i+1)
      behav.mem [i] = {19 {$random}};
      end
   endtask // FillRandom

`endif // SYNTHESIS 

   generate
         if (PIPELINE == 0)
            assign DOUT = DOUT_tmp;
         else 
            RamWrapPipe #(.WIDTH(width),.PIPELINE(PIPELINE),.CORE_PIPE(0)) pipe(.clk(CLK_1X),.gaten(SELN_R),.pipein(DOUT_tmp),.pipeout(DOUT));
   endgenerate

endmodule // RAMWRAP_1R1W_FULL_512X579
`endif // !SYNTHESIS

/* DO NOT EDIT THIS FILE
   File generated by:
	/auto/dsbu-asic/view/head/bin/vpp.pl \
	 -perl +define+output_file=cisco_generic_RAMWRAP_1R1W_FULL_1024X16.v \
	/auto/dsbu-asic/view/head_dopplerds_G0165/wrappers/cisco_generic_RAMWRAP_1R1W.vs
*/
// $Id: cisco_generic_RAMWRAP_1R1W.vs,v 1.19 2014/07/18 01:59:09 anrobbin Exp $
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006, Cisco Systems, Inc.
// All Rights Reserved.
//
// This is UNPUBLISHED PROPRIETARY SOURCE CODE of Cisco Systems, Inc;
// the contents of this file may not be disclosed to third parties, copied or
// duplicated in any form, in whole or in part, without the prior written
// permission of Cisco Systems, Inc.
//
// RESTRICTED RIGHTS LEGEND:
// Use, duplication or disclosure by the Government is subject to restrictions
// as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
// and Computer Software clause at DFARS 252.227-7013, and/or in similar or
// successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
// rights reserved under the Copyright Laws of the United States.
//
//////////////////////////////////////////////////////////////////////////////
//
// File          : cisco_generic_RAMWRAP_1R1W.vs
// Author        : Pete Johnson (petjohns@cisco.com)
// Description   : Generic Two Port RAM wrapper
//
//
//////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ns
`ifdef SYNTHESIS
`ifdef MANGLE
module RAMWRAP_1R1W_FULL_1024X16 #(  parameter depth=1024,
  parameter width=16,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);
      function integer log2;
    input [31:0] value;
    reg [31:0] v; // not reusing value because of DC warning
    begin
       v = value-1;
       for (log2=0; v>0; log2=log2+1)
         v = v>>1;
    end
      endfunction
endmodule // RAMWRAP_1R1W_FULL_1024X16
`endif // MANGLE
`else // !SYNTHESIS

`ifndef MACRO_log2
`include "log2.vh"
`endif

  module RAMWRAP_1R1W_FULL_1024X16 #(  parameter depth=1024,
  parameter width=16,
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (
  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
);

   `MACRO_log2

   wire [width-1:0] DOUT_tmp;

//VCS coverage off
   initial if ($test$plusargs("MEM_ANNOUNCE")) $display("RAMWRAP_1R1W_FULL_1024X16: Generic: %m");
//VCS coverage on

   RAMWRAP_1R1WAC_FULL_model
     #(.depth (1024),.width (16),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH), .PIPELINE(PIPELINE) )
   behav
     ( .CLK_R (CLK_1X),
       .CLK_W (CLK_1X),
       .POWER_CTL (POWER_CTL),
       .SELN_R (SELN_R),
       .A_R (A_R),
       .SELN_W (SELN_W),
       .A_W (A_W),
       .WEN (WEN),
       .DIN (DIN),
       .DOUT (DOUT_tmp)
       );

`ifdef SYNTHESIS
`else

   function [width-1:0] ReadWord;
      input [log2(depth)-1:0] addr;
      begin
    ReadWord = behav.mem [addr];
      end
   endfunction // ReadWord

   task WriteWord;
      input [log2(depth)-1:0] addr;
      input [width-1:0]     data;
      begin
    behav.mem [addr] = data;
      end
   endtask // WriteWord

   task FillZero;
      integer i;
      begin
    for (i=0; i<1024; i=i+1)
       behav.mem [i] = {width {1'b0}};
      end
   endtask // FillZero

   task FillOne;
      integer i;
      begin
    for (i=0; i<1024; i=i+1)
       behav.mem [i] = {width {1'b1}};
      end
   endtask // FillOne

   task FillRandom;
      integer i;
      begin
         for (i=0; i<1024; i=i+1)
      behav.mem [i] = {1 {$random}};
      end
   endtask // FillRandom

`endif // SYNTHESIS 

   generate
         if (PIPELINE == 0)
            assign DOUT = DOUT_tmp;
         else 
            RamWrapPipe #(.WIDTH(width),.PIPELINE(PIPELINE),.CORE_PIPE(0)) pipe(.clk(CLK_1X),.gaten(SELN_R),.pipein(DOUT_tmp),.pipeout(DOUT));
   endgenerate

endmodule // RAMWRAP_1R1W_FULL_1024X16
`endif // !SYNTHESIS
`timescale 1ns / 1ns
module RAMWRAP_1R1W_FULL #(   parameter depth=0,
  parameter width=0,
  parameter SUFFIX="",
  parameter DO_NOT_WRITE_X_ON_WRITE_THROUGH=0,
  parameter PIPELINE=0
) (

  input [`POWER_CTL_BUS_SIZE - 1:0] POWER_CTL,
  input CLK_1X,
  input CLK_2X,
  input SELN_R,
  input SELN_W,
  input [log2(depth)-1:0] A_R,
  input [log2(depth)-1:0] A_W,
  input WEN,
  input [width-1:0] DIN,
  output [width-1:0] DOUT
                   );
      function integer log2;
    input [31:0] value;
    reg [31:0] v; // not reusing value because of DC warning
    begin
       v = value-1;
       for (log2=0; v>0; log2=log2+1)
         v = v>>1;
    end
      endfunction

`ifdef SYNTHESIS
`else
   function [width-1:0] ReadWord;
      input [log2(depth)-1:0] addr;
      begin
         ReadWord = gen.U1.ReadWord(addr);
      end
   endfunction // ReadWord

   task WriteWord;
      input [log2(depth)-1:0] addr;
      input [width-1:0] data;
      begin
         gen.U1.WriteWord(addr,data);
      end
   endtask // WriteWord

   task FillZero;
      integer i;
      begin
         gen.U1.FillZero;
      end
   endtask // FillZero

   task FillOne;
      integer i;
      begin
         gen.U1.FillOne;
      end
   endtask // FillOne

   task FillRandom;
      integer i;
      begin
         gen.U1.FillRandom;
      end
   endtask // FillRandom
`endif // SYNTHESIS

   generate
         if (depth == 1024 && width == 10 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X10 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 12 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X12 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 142 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X142 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 15 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X15 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 18 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X18 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 23 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X23 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 24 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X24 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 29 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X29 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 30 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X30 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 568 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X568 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 579 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X579 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 59 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X59 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 67 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X67 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 128 && width == 2 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_128X2 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 128 && width == 52 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_128X52 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 2048 && width == 18 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_2048X18 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 2048 && width == 24 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_2048X24 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 256 && width == 10 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_256X10 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 256 && width == 15 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_256X15 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 2 && width == 2 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_2X2 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 2 && width == 52 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_2X52 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 32 && width == 2 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_32X2 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 4096 && width == 161 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_4096X161 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 4096 && width == 18 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_4096X18 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5136 && width == 1096 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5136X1096 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5136 && width == 1108 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5136X1108 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5136 && width == 13 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5136X13 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5136 && width == 19 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5136X19 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5376 && width == 1096 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5376X1096 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5376 && width == 19 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5376X19 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 5376 && width == 69 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_5376X69 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 512 && width == 22 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_512X22 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 512 && width == 15 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_512X15 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 512 && width == 579 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_512X579 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else if (depth == 1024 && width == 16 && SUFFIX == "")
           begin : gen
              RAMWRAP_1R1W_FULL_1024X16 #( .PIPELINE(PIPELINE),.DO_NOT_WRITE_X_ON_WRITE_THROUGH (DO_NOT_WRITE_X_ON_WRITE_THROUGH) ) U1(.CLK_1X(CLK_1X),.CLK_2X(CLK_2X),.SELN_R(SELN_R),.SELN_W(SELN_W),.A_R(A_R),.A_W(A_W),.WEN(WEN),.POWER_CTL(POWER_CTL),.DIN(DIN),.DOUT(DOUT));
           end
         else
           begin : gen
              if (1) begin : U1 // forced scope
`ifdef SYNTHESIS
`else
              function [width-1:0] ReadWord;
                 input [1:0] addr;
                 begin
                 end
              endfunction // ReadWord

              task WriteWord;
                 input [1:0] addr;
                 input [width-1:0] data;
                 begin
                 end
              endtask // WriteWord

              task FillZero;
                 begin
                 end
              endtask // FillZero

              task FillOne;
                 begin
                 end
              endtask // FillOne

              task FillRandom;
                 begin
                 end
              endtask // FillRandom

              initial
                 begin
                    $display("***ERROR: %m depth(%0d), width(%0d), and SUFFIX(\"%0s\") parameter values do not match any specified RAMWRAP_1R1W_FULL modules.",depth,width,SUFFIX);
                    $display("	The wrapper specification file contains...");
                    $display("		RAMWRAP_1R1W_FULL_1024X10");
                    $display("		RAMWRAP_1R1W_FULL_1024X12");
                    $display("		RAMWRAP_1R1W_FULL_1024X142");
                    $display("		RAMWRAP_1R1W_FULL_1024X15");
                    $display("		RAMWRAP_1R1W_FULL_1024X18");
                    $display("		RAMWRAP_1R1W_FULL_1024X23");
                    $display("		RAMWRAP_1R1W_FULL_1024X24");
                    $display("		RAMWRAP_1R1W_FULL_1024X29");
                    $display("		RAMWRAP_1R1W_FULL_1024X30");
                    $display("		RAMWRAP_1R1W_FULL_1024X568");
                    $display("		RAMWRAP_1R1W_FULL_1024X579");
                    $display("		RAMWRAP_1R1W_FULL_1024X59");
                    $display("		RAMWRAP_1R1W_FULL_1024X67");
                    $display("		RAMWRAP_1R1W_FULL_128X2");
                    $display("		RAMWRAP_1R1W_FULL_128X52");
                    $display("		RAMWRAP_1R1W_FULL_2048X18");
                    $display("		RAMWRAP_1R1W_FULL_2048X24");
                    $display("		RAMWRAP_1R1W_FULL_256X10");
                    $display("		RAMWRAP_1R1W_FULL_256X15");
                    $display("		RAMWRAP_1R1W_FULL_2X2");
                    $display("		RAMWRAP_1R1W_FULL_2X52");
                    $display("		RAMWRAP_1R1W_FULL_32X2");
                    $display("		RAMWRAP_1R1W_FULL_4096X161");
                    $display("		RAMWRAP_1R1W_FULL_4096X18");
                    $display("		RAMWRAP_1R1W_FULL_5136X1096");
                    $display("		RAMWRAP_1R1W_FULL_5136X1108");
                    $display("		RAMWRAP_1R1W_FULL_5136X13");
                    $display("		RAMWRAP_1R1W_FULL_5136X19");
                    $display("		RAMWRAP_1R1W_FULL_5376X1096");
                    $display("		RAMWRAP_1R1W_FULL_5376X19");
                    $display("		RAMWRAP_1R1W_FULL_5376X69");
                    $display("	You should add RAMWRAP_1R1W_FULL_%0dX%0d%0s to the wrapper specification file.\n",depth,width,SUFFIX);
                    #0;
                    $display("***ERROR: Aborting simulation due to parameterized RAM wrapper errors.");
                    $display("***       Please check the log file for parameterized RAM wrapper error messages.");
                    $finish;
                 end
`endif
              end // U1
           end // gen
    endgenerate

endmodule // RAMWRAP_1R1W_FULL
