#!/usr/bin/env tclsh
#set list "{mem_t1_bank0_cell_wsp0_dwrap_cell {0.0 0.0 ll} {67.68 182.02}} {mem_t1_bank0_cell_wsp1_dwrap_cell {67.68 0.0 ll} {135.36 182.02}} {mem_t1_bank0_cell_wsp2_dwrap_cell {135.36 0.0 ll} {203.04 182.02}} {mem_t1_bank0_cell_wsp3_dwrap_cell {203.04 0.0 ll} {270.72 182.02}} {mem_t1_bank0_cell_wsp4_dwrap_cell {270.72 0.0 ll} {338.4 182.02}} {mem_t1_bank0_cell_wsp5_dwrap_cell {338.4 0.0 ll} {406.08 182.02}} {mem_t1_bank0_cell_wsp6_dwrap_cell {406.08 0.0 ll} {473.76 182.02}} {mem_t1_bank0_cell_wsp7_dwrap_cell {473.76 0.0 ll} {541.44 182.02}} {mem_t1_bank0_cell_wsp8_dwrap_cell {541.44 0.0 ll} {609.12 182.02}} {mem_t1_bank0_cell_wsp9_dwrap_cell {609.12 0.0 ll} {676.8 182.02}} {mem_t1_bank0_cell_wsp10_dwrap_cell {676.8 0.0 ll} {744.48 182.02}} {mem_t1_bank0_cell_wsp11_dwrap_cell {744.48 0.0 ll} {812.16 182.02}} {mem_t1_bank0_cell_wsp12_dwrap_cell {812.16 0.0 ll} {879.84 182.02}} {mem_t1_bank0_cell_wsp13_dwrap_cell {879.84 0.0 ll} {947.52 182.02}} {mem_t1_bank0_cell_wsp14_dwrap_cell {947.52 0.0 ll} {1015.2 182.02}} {mem_t1_bank0_cell_wsp15_dwrap_cell {1015.2 0.0 ll} {1082.88 182.02}} {mem_t1_bank0_cell_wsp16_dwrap_cell {1425.21 0.0 lr} {1357.53 182.02}} {mem_t1_bank0_cell_wsp17_dwrap_cell {1492.89 0.0 lr} {1425.21 182.02}} {mem_t1_bank0_cell_wsp18_dwrap_cell {1560.57 0.0 lr} {1492.89 182.02}} {mem_t1_bank0_cell_wsp19_dwrap_cell {1628.25 0.0 lr} {1560.57 182.02}} {mem_t1_bank0_cell_wsp20_dwrap_cell {1695.93 0.0 lr} {1628.25 182.02}} {mem_t1_bank0_cell_wsp21_dwrap_cell {1763.61 0.0 lr} {1695.93 182.02}} {mem_t1_bank0_cell_wsp22_dwrap_cell {1831.29 0.0 lr} {1763.61 182.02}} {mem_t1_bank0_cell_wsp23_dwrap_cell {1898.97 0.0 lr} {1831.29 182.02}} {mem_t1_bank0_cell_wsp24_dwrap_cell {1966.65 0.0 lr} {1898.97 182.02}} {mem_t1_bank0_cell_wsp25_dwrap_cell {2034.33 0.0 lr} {1966.65 182.02}} {mem_t1_bank0_cell_wsp26_dwrap_cell {2102.01 0.0 lr} {2034.33 182.02}} {mem_t1_bank0_cell_wsp27_dwrap_cell {2169.69 0.0 lr} {2102.01 182.02}} {mem_t1_bank0_cell_wsp28_dwrap_cell {2237.37 0.0 lr} {2169.69 182.02}} {mem_t1_bank0_cell_wsp29_dwrap_cell {2305.05 0.0 lr} {2237.37 182.02}} {mem_t1_bank0_cell_wsp30_dwrap_cell {2372.73 0.0 lr} {2305.05 182.02}} {mem_t1_bank0_cell_wsp31_dwrap_cell {2440.41 0.0 lr} {2372.73 182.02}}"
#set list "{mem_t1_bank0_cell_wsp0_dwrap_cell {473.76 447.14 ul} {541.44 265.12}} {mem_t1_bank0_cell_wsp1_dwrap_cell {406.08 447.14 ul} {473.76 265.12}} {mem_t1_bank0_cell_wsp2_dwrap_cell {338.4 447.14 ul} {406.08 265.12}} {mem_t1_bank0_cell_wsp3_dwrap_cell {270.72 447.14 ul} {338.4 265.12}} {mem_t1_bank0_cell_wsp4_dwrap_cell {203.04 447.14 ul} {270.72 265.12}} {mem_t1_bank0_cell_wsp5_dwrap_cell {135.36 447.14 ul} {203.04 265.12}} {mem_t1_bank0_cell_wsp6_dwrap_cell {67.68 447.14 ul} {135.36 265.12}} {mem_t1_bank0_cell_wsp7_dwrap_cell {0.0 447.14 ul} {67.68 265.12}} {mem_t1_bank0_cell_wsp8_dwrap_cell {0.0 0.0 ll} {67.68 182.02}} {mem_t1_bank0_cell_wsp9_dwrap_cell {67.68 0.0 ll} {135.36 182.02}} {mem_t1_bank0_cell_wsp10_dwrap_cell {135.36 0.0 ll} {203.04 182.02}} {mem_t1_bank0_cell_wsp11_dwrap_cell {203.04 0.0 ll} {270.72 182.02}} {mem_t1_bank0_cell_wsp12_dwrap_cell {270.72 0.0 ll} {338.4 182.02}} {mem_t1_bank0_cell_wsp13_dwrap_cell {338.4 0.0 ll} {406.08 182.02}} {mem_t1_bank0_cell_wsp14_dwrap_cell {406.08 0.0 ll} {473.76 182.02}} {mem_t1_bank0_cell_wsp15_dwrap_cell {473.76 0.0 ll} {541.44 182.02}} {mem_t1_bank0_cell_wsp16_dwrap_cell {609.12 0.0 lr} {541.44 182.02}} {mem_t1_bank0_cell_wsp17_dwrap_cell {676.8 0.0 lr} {609.12 182.02}} {mem_t1_bank0_cell_wsp18_dwrap_cell {744.48 0.0 lr} {676.8 182.02}} {mem_t1_bank0_cell_wsp19_dwrap_cell {812.16 0.0 lr} {744.48 182.02}} {mem_t1_bank0_cell_wsp20_dwrap_cell {879.84 0.0 lr} {812.16 182.02}} {mem_t1_bank0_cell_wsp21_dwrap_cell {947.52 0.0 lr} {879.84 182.02}} {mem_t1_bank0_cell_wsp22_dwrap_cell {1015.2 0.0 lr} {947.52 182.02}} {mem_t1_bank0_cell_wsp23_dwrap_cell {1082.88 0.0 lr} {1015.2 182.02}} {mem_t1_bank0_cell_wsp24_dwrap_cell {1082.88 447.14 ur} {1015.2 265.12}} {mem_t1_bank0_cell_wsp25_dwrap_cell {1015.2 447.14 ur} {947.52 265.12}} {mem_t1_bank0_cell_wsp26_dwrap_cell {947.52 447.14 ur} {879.84 265.12}} {mem_t1_bank0_cell_wsp27_dwrap_cell {879.84 447.14 ur} {812.16 265.12}} {mem_t1_bank0_cell_wsp28_dwrap_cell {812.16 447.14 ur} {744.48 265.12}} {mem_t1_bank0_cell_wsp29_dwrap_cell {744.48 447.14 ur} {676.8 265.12}} {mem_t1_bank0_cell_wsp30_dwrap_cell {676.8 447.14 ur} {609.12 265.12}} {mem_t1_bank0_cell_wsp31_dwrap_cell {609.12 447.14 ur} {541.44 265.12}}"
#set list "{mem_t1_bank0_cell_wsp0_dwrap_cell {203.04 728.06 ul} {270.72 546.04}} {mem_t1_bank0_cell_wsp1_dwrap_cell {203.04 546.05 ul} {270.72 364.03}} {mem_t1_bank0_cell_wsp2_dwrap_cell {135.36 728.06 ul} {203.04 546.04}} {mem_t1_bank0_cell_wsp3_dwrap_cell {67.68 728.06 ul} {135.36 546.04}} {mem_t1_bank0_cell_wsp4_dwrap_cell {135.36 546.05 ul} {203.04 364.03}} {mem_t1_bank0_cell_wsp5_dwrap_cell {67.68 546.05 ul} {135.36 364.03}} {mem_t1_bank0_cell_wsp6_dwrap_cell {0.0 728.06 ul} {67.68 546.04}} {mem_t1_bank0_cell_wsp7_dwrap_cell {0.0 546.05 ul} {67.68 364.03}} {mem_t1_bank0_cell_wsp8_dwrap_cell {0.0 182.02 ll} {67.68 364.04}} {mem_t1_bank0_cell_wsp9_dwrap_cell {67.68 182.02 ll} {135.36 364.04}} {mem_t1_bank0_cell_wsp10_dwrap_cell {0.0 0.0 ll} {67.68 182.02}} {mem_t1_bank0_cell_wsp11_dwrap_cell {67.68 0.0 ll} {135.36 182.02}} {mem_t1_bank0_cell_wsp12_dwrap_cell {135.36 182.02 ll} {203.04 364.04}} {mem_t1_bank0_cell_wsp13_dwrap_cell {203.04 182.02 ll} {270.72 364.04}} {mem_t1_bank0_cell_wsp14_dwrap_cell {135.36 0.0 ll} {203.04 182.02}} {mem_t1_bank0_cell_wsp15_dwrap_cell {203.04 0.0 ll} {270.72 182.02}} {mem_t1_bank0_cell_wsp16_dwrap_cell {338.4 0.0 lr} {270.72 182.02}} {mem_t1_bank0_cell_wsp17_dwrap_cell {406.08 0.0 lr} {338.4 182.02}} {mem_t1_bank0_cell_wsp18_dwrap_cell {473.76 0.0 lr} {406.08 182.02}} {mem_t1_bank0_cell_wsp19_dwrap_cell {473.76 182.02 lr} {406.08 364.04}} {mem_t1_bank0_cell_wsp20_dwrap_cell {541.44 0.0 lr} {473.76 182.02}} {mem_t1_bank0_cell_wsp21_dwrap_cell {609.12 0.0 lr} {541.44 182.02}} {mem_t1_bank0_cell_wsp22_dwrap_cell {541.44 182.02 lr} {473.76 364.04}} {mem_t1_bank0_cell_wsp23_dwrap_cell {609.12 182.02 lr} {541.44 364.04}} {mem_t1_bank0_cell_wsp24_dwrap_cell {609.12 546.05 ur} {541.44 364.03}} {mem_t1_bank0_cell_wsp25_dwrap_cell {541.44 546.05 ur} {473.76 364.03}} {mem_t1_bank0_cell_wsp26_dwrap_cell {609.12 728.06 ur} {541.44 546.04}} {mem_t1_bank0_cell_wsp27_dwrap_cell {541.44 728.06 ur} {473.76 546.04}} {mem_t1_bank0_cell_wsp28_dwrap_cell {473.76 546.05 ur} {406.08 364.03}} {mem_t1_bank0_cell_wsp29_dwrap_cell {473.76 728.06 ur} {406.08 546.04}} {mem_t1_bank0_cell_wsp30_dwrap_cell {406.08 728.06 ur} {338.4 546.04}} {mem_t1_bank0_cell_wsp31_dwrap_cell {338.4 728.06 ur} {270.72 546.04}}"
proc lremove {args} {
     if {[llength $args] < 2} {
        puts stderr {Wrong # args: should be "lremove ?-all? list pattern"}
     }
     set list [lindex $args end-1]
     set elements [lindex $args end]
     if [string match -all [lindex $args 0]] {
        foreach element $elements {
            set list [lsearch -all -inline -not -exact $list $element]
        }
     } else {
        # Using lreplace to truncate the list saves having to calculate
        # ranges or offsets from the indexed element. The trimming is
        # necessary in cases where the first or last element is the
        # indexed element.
        foreach element $elements {
            set idx [lsearch $list $element]
            set list [string trim "[lreplace $list $idx end] [lreplace $list 0 $idx]"]

        }
     }
	#puts "\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n$list\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
	return $list

}


proc find_maxx_maxy {list} \
{
	foreach var $list {
		#puts $var
		set maxX [lindex [lsort -uniq -real [lappend maxXlist [lindex $var 1 0] [lindex $var 2 0]]] end]
		set maxY [lindex [lsort -uniq -real [lappend maxYlist [lindex $var 1 1] [lindex $var 2 1]]] end]
		set maxlist [list $maxX $maxY]
	}
	return $maxlist
	
}
#set asd 12.00002


proc round {expr} \
{
	set value [expr {abs(double(round(1000*($expr))))/1000}]
	return $value
}

proc coreedge {list} \
{
	foreach var $list {
		set maxX [lindex [lsort -uniq -real [lappend maxXlist [lindex $var 1 0] [lindex $var 2 0]]] end]
		set maxY [lindex [lsort -uniq -real [lappend maxYlist [lindex $var 1 1] [lindex $var 2 1]]] end]
	}
	set coreedges "\{\{0.0 0.0\} \{0.0 $maxY\} r\}\
				   \{\{0.0 0.0\} \{$maxX 0.0\} t\}\
				   \{\{0.0 $maxY\} \{$maxX $maxY\} b\}\
				   \{\{$maxX 0.0\} \{$maxX $maxY\} l\}"
    return $coreedges
}


proc edges {list} \
{
	foreach var $list {
		set maxX [lindex [lsort -uniq -real [lappend maxXlist [lindex $var 1 0] [lindex $var 2 0]]] end]
		set maxY [lindex [lsort -uniq -real [lappend maxYlist [lindex $var 1 1] [lindex $var 2 1]]] end]
		set x1 [lindex $var 1 0]
		set x2 [lindex $var 2 0]
		set xlist [lsort -real  [list $x1 $x2]]
		set y1 [lindex $var 1 1]
		set y2 [lindex $var 2 1]
		set ylist [lsort -real [list $y1 $y2]]
		set bbox "\{[lindex $xlist 0] [lindex $ylist 0]\} \{[lindex $xlist end] [lindex $ylist end]\}"
		set bboxlist [lsort -real -index {0 0} [lsort -u [lappend bboxlst $bbox]]]

	}
	set vertedge {}
	set horzedge {}
	foreach bank $bboxlist {
		set minx [lindex $bank 0 0]
		set miny [lindex $bank 0 1]
		set maxx [lindex $bank 1 0]
		set maxy [lindex $bank 1 1]
		set horzedge1 "\{$minx $maxy\} \{$maxx $maxy\} t"
		set horzedge2 "\{$minx $miny\} \{$maxx $miny\} b"
		set vertedge1 "\{$maxx $miny\} \{$maxx $maxy\} r"
		set vertedge2 "\{$minx $miny\} \{$minx $maxy\} l"
		lappend vertedg $vertedge1 $vertedge2 
		lappend horzedg $horzedge1 $horzedge2
	}
	set coreedges [coreedge $list]
				   
	set fulledgelist [join [lappend fulledg $vertedg $horzedg $coreedges]]
	return $fulledgelist
}

proc plus_edge {edgea edgeb} \
{
#	set pairlist "\{$edgea $edgeb\} \{$edgeb $edgea\}"
	set pair2 [list $edgea $edgeb]
	set edge1 [lindex $pair2 0]
	set edge2 [lindex $pair2 end]
	set edge3 [lindex $pair2 0]
	set edge4 [lindex $pair2 end]
	set newedgepair {}
	if {[lindex $edge1 0 0]==[lindex $edge1 1 0] && \
		[lindex $edge2 0 0]==[lindex $edge2 1 0] && \
		[lindex $edge1 0 0]==[lindex $edge2 1 0] && \
		[lindex $edge1 2]==[lindex $edge2 2]} {
			set miny1 [lindex $edge1 0 1]
			set miny2 [lindex $edge2 0 1]
			set maxy1 [lindex $edge1 1 1]
			set maxy2 [lindex $edge2 1 1]
			set x1 [lindex $edge1 0 0]
			set x2 [lindex $edge2 0 0]
			set side [lindex $edge1 2]
			#puts "##############################################################"
			if {$maxy1==$miny2} {
				lappend newedgepair "\{$x1 $miny1\} \{$x1 $maxy2\} $side" 
				} elseif {$maxy2==$miny1} {
					lappend newedgepair "\{$x1 $miny2\} \{$x1 $maxy1\} $side" 
					} elseif {$miny1<$miny2 && \
							  $maxy1>$miny2 && \
						  	  $maxy1<$maxy2} {
								  lappend newedgepair "\{$x1 $miny1\} \{$x1 $maxy2\} $side"
								  } elseif {$miny2<$miny1 && \
							 		 		$maxy2>$miny1 && \
						  					$maxy2<$maxy1} {
											lappend newedgepair "\{$x1 $miny2\} \{$x1 $maxy1\} $side"
											} elseif {$miny1<$miny2 && \
													  $maxy1>$maxy2} {
													  lappend newedgepair "$edge1"
													  } elseif {$miny2<$miny1 && \
													  			$maxy2>$maxy1} {
																lappend newedgepair "$edge2"
																} elseif {$maxy1<$miny2 && \
																		  $maxx1==$maxx2} {
																		  lappend newedgepair "$edge1"
															 				} elseif {$miny1==$miny2 && \
													 						   		  $maxy1>$maxy2} {
															 							lappend newedgepair "$edge1"
																						} elseif {$miny1==$miny2 && \
																								$maxy1<$maxy2} {
																								#lappend newedgepair "$edge2"
																								} else {
																	 								set newedgeplair {}
																	 					}
                                                             				

		} 
		
	if {[lindex $edge3 0 1]==[lindex $edge3 1 1] && \
		[lindex $edge4 0 1]==[lindex $edge4 1 1] && \
		[lindex $edge3 0 1]==[lindex $edge4 0 1] && \
		[lindex $edge3 2]==[lindex $edge4 2]} {
			set minx1 [lindex $edge3 0 0]
			set minx2 [lindex $edge4 0 0]
			set maxx1 [lindex $edge3 1 0]
			set maxx2 [lindex $edge4 1 0]
			set y1 [lindex $edge3 0 1]
			set y2 [lindex $edge4 0 1]
			set side [lindex $edge3 2]
			if {$maxx1==$minx2} {
				lappend newedgepair "\{$minx1 $y1\} \{$maxx2 $y1\} $side" 
				} elseif {$maxx2==$minx1} {
					lappend newedgepair "\{$minx2 $y1\} \{$maxx1 $y1\} $side" 
					} elseif {$minx1<$minx2 && \
							  $maxx1>$minx2 && \
						  	  $maxx1<$maxx2} {
								  lappend newedgepair "\{$minx1 $y1\} \{$maxx2 $y1\} $side"
								  } elseif {$minx2<$minx1 && \
							 		 		$maxx2>$minx1 && \
						  					$maxx2<$maxx1} {
											lappend newedgepair "\{$minx2 $y1\} \{$maxx1 $y1\} $side"
											} elseif {$minx1<$minx2 && \
													  $maxx1>$maxx2} {
													  lappend newedgepair "$edge3"
													  } elseif {$minx2<$minx1 && \
													  			$maxx2>$maxx1} {
																lappend newedgepair "$edge4"
																} elseif {$minx1==$minx2 && \
																		  $maxx1>$maxx2} {
															 					lappend newedgepair "$edge3"
															 					#lappend newedgepair $edge1
																				} elseif {$minx1==$minx2 && \
																		  		  			$maxx1<$maxx2} {
																		 					lappend newedgepair "$edge4"
																		 					#lappend newedgepair $edge1
																		 					} elseif {$minx1<$minx2 && \
																									  $maxx1==$maxx2} {
																		 									#lappend newedgepair "$edge3"
																		 										} else {
																		 											set newedgeplair {}
																		 										}
		
	} 
	#puts "init list $edgea $edgeb"
	#puts "new edge  $newedgepair"
	#puts "new pair $newedgepair\n"
	return $newedgepair
}
#############################################################################
proc minus_edge {edgea edgeb} \
{
	set pair1 [list $edgea $edgeb]
	set edge1 [lindex $pair1 0]
	set edge2 [lindex $pair1 end]
	set edge3 [lindex $pair1 0]
	set edge4 [lindex $pair1 end]
	set newedgepair {}
	if {[lindex $edge1 0 0]==[lindex $edge1 1 0] && \
		[lindex $edge2 0 0]==[lindex $edge2 1 0] && \
		[lindex $edge1 0 0]==[lindex $edge2 0 0] && \
		[lindex $edge1 2]!=[lindex $edge2 2]} {
			set miny1 [lindex $edge1 0 1]
			set miny2 [lindex $edge2 0 1]
			set maxy1 [lindex $edge1 1 1]
			set maxy2 [lindex $edge2 1 1]
			set x1 [lindex $edge1 0 0]
			set x2 [lindex $edge2 0 0]
			set side1 [lindex $edge1 2]
			set side2 [lindex $edge2 2]
			if {$miny1<$miny2 && \
			    $maxy1>$miny2 && \
				$maxy1<$maxy2} {
				set newedge1 "\{$x1 $miny1\} \{$x1 $miny2\} $side1"
				set newedge2 "\{$x1 $maxy1\} \{$x1 $maxy2\} $side2"
				lappend newedgepair $newedge1 $newedge2
				} elseif {$miny2<$miny1 && \
			   			  $maxy2>$miny1 && \
						  $maxy2<$maxy1} {
						  set newedge1 "\{$x1 $miny2\} \{$x1 $miny1\} $side2"
						  set newedge2 "\{$x1 $maxy2\} \{$x1 $maxy1\} $side1"
						  lappend newedgepair $newedge1 $newedge2
						  } elseif {$miny1<$miny2 && \
							  		$maxy1>$maxy2} {
									set newedge1 "\{$x1 $miny1\} \{$x1 $miny2\} $side1"
									set newedge2 "\{$x1 $maxy2\} \{$x1 $maxy1\} $side1"
									lappend newedgepair $newedge1 $newedge2	
									} elseif {$miny2<$miny1 && \
											  $maxy2>$maxy1} {
			  								  set newedge1 "\{$x1 $miny2\} \{$x1 $miny1\} $side2"
			  								  set newedge2 "\{$x1 $maxy1\} \{$x1 $maxy2\} $side2"
			  								  lappend newedgepair $newedge1 $newedge2  
											  } elseif {$miny1==$miny2 && \
											  			$maxy1>$maxy2} {
															lappend newedgepair "\{$x1 $maxy2\} \{$x1 $maxy1\} $side1" 
															} elseif {$maxy1==$maxy2 && \
																	  $miny1<$miny2} {
																		  lappend newedgepair "\{$x1 $miny1\} \{$x1 $miny2\} $side1"
																		  } elseif {$miny2==$miny1 && \
																		  			$maxy2>$maxy1} {
																						lappend newedgepair "\{$x1 $maxy1\} \{$x1 $maxy2\} $side2" 
																						} elseif {$maxy2==$maxy1 && \
																								  $miny2<$miny1} {
																									  lappend newedgepair "\{$x1 $miny2\} \{$x1 $miny1\} $side2"
							    																	  } else {
							    																		  set newedgepair {}
							    																	  } 
                                

		} 
	if {[lindex $edge3 0 1]==[lindex $edge3 1 1] && \
		[lindex $edge4 0 1]==[lindex $edge4 1 1] && \
		[lindex $edge3 0 1]==[lindex $edge4 0 1] && \
		[lindex $edge3 2]!=[lindex $edge4 2]} {
			set minx1 [lindex $edge3 0 0]
			set minx2 [lindex $edge4 0 0]
			set maxx1 [lindex $edge3 1 0]
			set maxx2 [lindex $edge4 1 0]
			set y1 [lindex $edge3 0 1]
			set y2 [lindex $edge4 0 1]
			set side1 [lindex $edge3 2]
			set side2 [lindex $edge4 2]
			if {$minx1<$minx2 && \
			    $maxx1>$minx2 && \
				$maxx1<$maxx2} {
				set newedge1 "\{$minx1 $y1\} \{$minx2 $y1\} $side1"
				set newedge2 "\{$maxx1 $y1\} \{$maxx2 $y1\} $side2"
				lappend newedgepair $newedge1 $newedge2
				} elseif {$minx2<$minx1 && \
			   			  $maxx2>$minx1 && \
						  $maxx2<$maxx1} {
						  set newedge1 "\{$minx2 $y1\} \{$minx1 $y1\} $side2"
						  set newedge2 "\{$maxx2 $y1\} \{$maxx1 $y1\} $side1"
						  lappend newedgepair $newedge1 $newedge2
						  } elseif {$minx1<$minx2 && \
							  		$maxx1>$maxx2} {
									set newedge1 "\{$minx1 $y1\} \{$minx2 $y1\} $side1"
									set newedge2 "\{$maxx2 $y1\} \{$maxx1 $y1\} $side1"
									lappend newedgepair $newedge1 $newedge2	
									} elseif {$minx2<$minx1 && \
											  $maxx2>$maxx1} {
			  								  set newedge1 "\{$minx2 $y1\} \{$minx1 $y1\} $side2"
			  								  set newedge2 "\{$maxx1 $y1\} \{$maxx2 $y1\} $side2"
			  								  lappend newedgepair $newedge1 $newedge2  
											  } elseif {$minx1==$minx2 && \
											  			$maxx1>$maxx2} {
															lappend newedgepair "\{$maxx2 $y1\} \{$maxx1 $y1\} $side1"
															} elseif {$maxx1==$maxx2 && \
											  						  $minx1<$minx2} {
																		  lappend newedgepair "\{$minx1 $y1\} \{$minx2 $y1\} $side1"
																		  } elseif {$minx2==$minx1 && \
																		  			$maxx2>$maxx1} {
																						lappend newedgepair "\{$maxx1 $y1\} \{$maxx2 $y1\} $side2"
																						} elseif {$maxx2==$maxx1 && \
																		  						  $minx2<$minx1} {
																									  lappend newedgepair "\{$minx2 $y1\} \{$minx1 $y1\} $side2"
							    																		  } else {
																											  set newedgepair {}
							    																		  } 
		} 
	
	#puts "init list $edgea $edgeb"
	#puts "new edge  $newedgepair"
	#puts "new pair $newedgepair\n"
	return $newedgepair
}

proc minus_edge_same {edgea edgeb} \
{
	set pair1 [list $edgea $edgeb]
	set edge1 [lindex $pair1 0]
	set edge2 [lindex $pair1 end]
	set edge3 [lindex $pair1 0]
	set edge4 [lindex $pair1 end]
	set newedgepair {}
	if {[lindex $edge1 0 0]==[lindex $edge1 1 0] && \
		[lindex $edge2 0 0]==[lindex $edge2 1 0] && \
		[lindex $edge1 0 0]==[lindex $edge2 0 0] && \
		[lindex $edge1 2]==[lindex $edge2 2]} {
			set miny1 [lindex $edge1 0 1]
			set miny2 [lindex $edge2 0 1]
			set maxy1 [lindex $edge1 1 1]
			set maxy2 [lindex $edge2 1 1]
			set x1 [lindex $edge1 0 0]
			set x2 [lindex $edge2 0 0]
			set side1 [lindex $edge1 2]
			set side2 [lindex $edge2 2]
			if {$miny1<$miny2 && \
			    $maxy1>$miny2 && \
				$maxy1<$maxy2} {
				set newedge1 "\{$x1 $miny1\} \{$x1 $miny2\} $side1"
				set newedge2 "\{$x1 $maxy1\} \{$x1 $maxy2\} $side2"
				lappend newedgepair $newedge1 $newedge2
				} elseif {$miny2<$miny1 && \
			   			  $maxy2>$miny1 && \
						  $maxy2<$maxy1} {
						  set newedge1 "\{$x1 $miny2\} \{$x1 $miny1\} $side2"
						  set newedge2 "\{$x1 $maxy2\} \{$x1 $maxy1\} $side1"
						  lappend newedgepair $newedge1 $newedge2
						  } elseif {$miny1<$miny2 && \
							  		$maxy1>$maxy2} {
									set newedge1 "\{$x1 $miny1\} \{$x1 $miny2\} $side1"
									set newedge2 "\{$x1 $maxy2\} \{$x1 $maxy1\} $side1"
									lappend newedgepair $newedge1 $newedge2	
									} elseif {$miny2<$miny1 && \
											  $maxy2>$maxy1} {
			  								  set newedge1 "\{$x1 $miny2\} \{$x1 $miny1\} $side2"
			  								  set newedge2 "\{$x1 $maxy1\} \{$x1 $maxy2\} $side2"
			  								  lappend newedgepair $newedge1 $newedge2  
											  } elseif {$miny1==$miny2 && \
											  			$maxy1>$maxy2} {
															lappend newedgepair "\{$x1 $maxy2\} \{$x1 $maxy1\} $side1" 
															} elseif {$maxy1==$maxy2 && \
																	  $miny1<$miny2} {
																		  lappend newedgepair "\{$x1 $miny1\} \{$x1 $miny2\} $side1"
																		  } elseif {$miny2==$miny1 && \
																		  			$maxy2>$maxy1} {
																						lappend newedgepair "\{$x1 $maxy1\} \{$x1 $maxy2\} $side2" 
																						} elseif {$maxy2==$maxy1 && \
																								  $miny2<$miny1} {
																									  lappend newedgepair "\{$x1 $miny2\} \{$x1 $miny1\} $side2"
							    																	  } else {
							    																		  set newedgepair {}
							    																	  } 
                                

		} 
	if {[lindex $edge3 0 1]==[lindex $edge3 1 1] && \
		[lindex $edge4 0 1]==[lindex $edge4 1 1] && \
		[lindex $edge3 0 1]==[lindex $edge4 0 1] && \
		[lindex $edge3 2]==[lindex $edge4 2]} {
			set minx1 [lindex $edge3 0 0]
			set minx2 [lindex $edge4 0 0]
			set maxx1 [lindex $edge3 1 0]
			set maxx2 [lindex $edge4 1 0]
			set y1 [lindex $edge3 0 1]
			set y2 [lindex $edge4 0 1]
			set side1 [lindex $edge3 2]
			set side2 [lindex $edge4 2]
			if {$minx1<$minx2 && \
			    $maxx1>$minx2 && \
				$maxx1<$maxx2} {
				set newedge1 "\{$minx1 $y1\} \{$minx2 $y1\} $side1"
				set newedge2 "\{$maxx1 $y1\} \{$maxx2 $y1\} $side2"
				lappend newedgepair $newedge1 $newedge2
				} elseif {$minx2<$minx1 && \
			   			  $maxx2>$minx1 && \
						  $maxx2<$maxx1} {
						  set newedge1 "\{$minx2 $y1\} \{$minx1 $y1\} $side2"
						  set newedge2 "\{$maxx2 $y1\} \{$maxx1 $y1\} $side1"
						  lappend newedgepair $newedge1 $newedge2
						  } elseif {$minx1<$minx2 && \
							  		$maxx1>$maxx2} {
									set newedge1 "\{$minx1 $y1\} \{$minx2 $y1\} $side1"
									set newedge2 "\{$maxx2 $y1\} \{$maxx1 $y1\} $side1"
									lappend newedgepair $newedge1 $newedge2	
									} elseif {$minx2<$minx1 && \
											  $maxx2>$maxx1} {
			  								  set newedge1 "\{$minx2 $y1\} \{$minx1 $y1\} $side2"
			  								  set newedge2 "\{$maxx1 $y1\} \{$maxx2 $y1\} $side2"
			  								  lappend newedgepair $newedge1 $newedge2  
											  } elseif {$minx1==$minx2 && \
											  			$maxx1>$maxx2} {
															lappend newedgepair "\{$maxx2 $y1\} \{$maxx1 $y1\} $side1"
															} elseif {$maxx1==$maxx2 && \
											  						  $minx1<$minx2} {
																		  lappend newedgepair "\{$minx1 $y1\} \{$minx2 $y1\} $side1"
																		  } elseif {$minx2==$minx1 && \
																		  			$maxx2>$maxx1} {
																						lappend newedgepair "\{$maxx1 $y1\} \{$maxx2 $y1\} $side2"
																						} elseif {$maxx2==$maxx1 && \
																		  						  $minx2<$minx1} {
																									  lappend newedgepair "\{$minx2 $y1\} \{$minx1 $y1\} $side2"
							    																		  } else {
																											  set newedgepair {}
							    																		  } 
		} 
	
	#puts "init list $edgea $edgeb"
	#puts "new edge  $newedgepair"
	#puts "new pair $newedgepair\n"
	return $newedgepair
}
#############################################################################
proc opp_edge {list} \
{
	set oldedge {}
	foreach edge3 $list {
		foreach edge4 $list { 
			if {[lindex $edge3 0]==[lindex $edge4 0] && \
				[lindex $edge3 1]==[lindex $edge4 1] && \
				[lindex $edge3 2]!=[lindex $edge4 2]} {
					set oldedge [lsort -uniq [lappend oldlist $edge3 $edge4]]
					#puts "\n$edge3 $edge4\n"
			}
		}	
	}

	set oldedgelist [lsort -uniq [lremove $list $oldedge]]
	return $oldedgelist
}


proc maximum_edge {list} \
{
	set l 1
	set m 1
	set k 1
	set e 1
	set ylinel {}
	set yliner {}
	set xlinet {}
	set xlineb {}
	set tedgelist {}
	set bedgelist {}
	set redgelist {}
	set ledgelist {}
	set rmlistt {}
	set rmlistb {}
	set rmlistl {}
	set rmlistr {}
	set newedgelist {}
	set oldedgelist {}
	set fullrmlist {}
	set fulledgelist {}
	
	set oldedgelist [opp_edge $list]
	#set oldedgelist [lsort -uniq [lremove $list $oldedge]]
	#puts "old edges $oldedgelist\n #########\n[llength $oldedgelist]"
	foreach edge3 $oldedgelist {
		#puts $edge3
		#puts $oldedgelist
		set xlist [lsort -uniq -real [lappend xlst [lindex $edge3 0 0]]]
		set ylist [lsort -uniq -real [lappend ylst [lindex $edge3 0 1]]]		
	}

	foreach x $xlist {
		set ylnel {}
		set ylner {}
		foreach edge4 $oldedgelist {
			if {[lindex $edge4 0 0]==$x && \
				[lindex $edge4 2]=="l"} {
					set ylinel [lsort -uniq [lappend ylnel $edge4 ]]
			}
			if {[lindex $edge4 0 0]==$x && \
				[lindex $edge4 2]=="r"} {
					set yliner [lsort -uniq [lappend ylner $edge4 ]]
			}
		}
		set ylinellist [lsort -uniq [lappend ylinellst $ylinel]]
		set ylinerlist [lsort -uniq [lappend ylinerlst $yliner]]
	}
	#puts "edges --- $ylinerlist"
	foreach y $ylist {
		set xlnet {}
		set xlneb {}
		foreach edge5 $oldedgelist {
				if {[lindex $edge5 0 1]==$y && \
					[lindex $edge5 2]=="t"} {
						set xlinet [lsort -uniq [lappend xlnet $edge5]]
				}
				if {[lindex $edge5 0 1]==$y && \
					[lindex $edge5 2]=="b"} {
						set xlineb [lsort -uniq [lappend xlneb $edge5]]
				}
			}
		set xlinetlist [lsort -uniq [lappend xlinetlst $xlinet]]
		set xlineblist [lsort -uniq [lappend xlineblst $xlineb]]
	}	
    #puts "\n##########\n$xlineblist\n##########\n"
	#puts "\n##########\n$xlinetlist\n##########\n"
	#puts "\n##########\n$ylinellist\n##########\n"
	#puts "\n##########\n$ylinerlist\n##########\n"	
	foreach xlinet $xlinetlist {
		set sortxline [lsort -index {0 0} -real $xlinet]
		set n [llength $sortxline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set tedge1 [lindex $sortxline $i]
				set tedge2 [lindex $sortxline $i+1]
				if {[lindex $tedge1 1 0]>=[lindex $tedge2 0 0] && \
					[lindex $tedge1 1 0]<=[lindex $tedge2 1 0]} {
						set tedge [plus_edge $tedge1 $tedge2]
						#set tedgelist [lsort -uniq [lappend tedgelst $tedge1 $tedge2]]
						set tedgelist  [lsort -uniq [lappend tedgelst $tedge]]
						#puts "$tedgelist created list"
						lappend rmlistt $tedge1 $tedge2
						
						set l 2
						} elseif {[lindex $tedge1 1 0]<[lindex $tedge2 0 0] && \
								  [lindex $tedge1 1 0]<[lindex $tedge2 1 0]} {
							set tedgelist [lsort -uniq [lappend tedgelst "\{$tedge1\}" "\{$tedge2\}"]]
							#puts "$tedgelist inherit list"
						}
					}	
			} elseif {$n==1} {
				set tedgelist [lappend tedgelst $sortxline]
				#puts "$tedgelist uniq list"
			}
	}
	foreach xlineb $xlineblist {
		set sortxline [lsort -index {0 0} -real $xlineb]
		set n [llength $sortxline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set bedge1 [lindex $sortxline $i]
				set bedge2 [lindex $sortxline $i+1]
				if {[lindex $bedge1 1 0]>=[lindex $bedge2 0 0] && \
					[lindex $bedge1 1 0]<=[lindex $bedge2 1 0]} {
					set bedge [plus_edge $bedge1 $bedge2]
					set bedgelist [lsort -uniq [lappend bedgelst $bedge]]
					lappend rmlistb $bedge1 $bedge2
					set m 2
					} elseif {[lindex $bedge1 1 0]<[lindex $bedge2 0 0] && \
							  [lindex $bedge1 1 0]<[lindex $bedge2 1 0]} {
								  set bedgelist [lsort -uniq [lappend bedgelst "\{$bedge1\}" "\{$bedge2\}"]]
					}
				}	
			} elseif {$n==1} {
				set  bedgelist [lappend bedgelst $sortxline]
			}
	}
		
	foreach yliner $ylinerlist {
		set sortyline [lsort -index {0 1} -real $yliner]
		set n [llength $sortyline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set redge1 [lindex $sortyline $i]
				set redge2 [lindex $sortyline $i+1]
				if {[lindex $redge1 1 1]>=[lindex $redge2 0 1] && \
					[lindex $redge1 1 1]<=[lindex $redge2 1 1]} {
					set redge [plus_edge $redge1 $redge2]
					set redgelist [lsort -uniq [lappend redgelst $redge]]
					lappend rmlistr $redge1 $redge2
					set k 2
					} elseif {[lindex $redge1 1 1]<[lindex $redge2 0 1] && \
							  [lindex $redge1 1 1]<[lindex $redge2 1 1]} {
						set redgelist [lsort -uniq [lappend redgelst "\{$redge1\}" "\{$redge2\}" ]]
					}
				}	
			} elseif {$n==1} {
				set  redgelist [lappend redgelst $sortyline]
				#puts "$redgelist unqi edge edge"
			
			}
	}
	foreach ylinel $ylinellist {
		set sortyline [lsort -index {0 1} -real $ylinel]
		set n [llength $sortyline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set ledge1 [lindex $sortyline $i]
				set ledge2 [lindex $sortyline $i+1]
				if {[lindex $ledge1 1 1]>=[lindex $ledge2 0 1] && \
					[lindex $ledge1 1 1]<=[lindex $ledge2 1 1]} {
					set ledge [plus_edge $ledge1 $ledge2]
					set ledgelist [lsort -uniq [lappend ledgelst $ledge]]
					lappend rmlistl $ledge1 $ledge2
					set e 2
					} elseif {[lindex $ledge1 1 1]<[lindex $ledge2 0 1] && \
							  [lindex $ledge1 1 1]<[lindex $ledge2 1 1]} {
								  set ledgelist [lsort -uniq [lappend ledgelst "\{$ledge1\}" "\{$ledge2\}"]]
					}
				}	
			} elseif {$n==1} {
				set  ledgelist [lappend ledgelst $sortyline]
			}
	}
	set fulledgelist [join [lsort -u [concat {*}[lappend filledgelst $ledgelist $redgelist $tedgelist $bedgelist]]]]
	set fullrmlist   [lsort -u [concat {*}[lappend fullrmlst $rmlistt $rmlistb $rmlistl $rmlistr]]]
	
	#puts "\n################\nfull edge list \n$fulledgelist\n#################\n###\n[llength $fulledgelist]\n###\n"
	#puts "\n################\nremove\n$fullrmlist\n#################\n###\n[llength $fullrmlist]\n###\n"
	#puts "\nremove edges remove edge $rmlistt\n############\n"
	set newlist [opp_edge [lsort -uniq [lremove $fulledgelist $fullrmlist]]]
    
	
    #puts "\n newlist ------- newlist \n$newlist\n#########\n[llength $newlist]\n##########"
	set nlist [lsort -u -real [lappend nlst $l $m $e $k]]
	#puts "nliiist $nlist"
	set n [lindex $nlist end]
	if {$n==2} {
		set edge [maximum_edge $newlist]
		#puts ">>>>>>$edge"
		} else {
			set newlist [lsort -uniq [lsort -real -index {0 0} $list]]
		#	puts "maximum list $newlist"
			return $newlist
	}
}
#############################################################################
#############################################################################

#puts [maximum_edge $fulledgelist]
proc minimum_edge_same {list} \
{
	set l 1
	set m 1
	set k 1
	set e 1
	set ylinel {}
	set yliner {}
	set xlinet {}
	set xlineb {}
	set tedgelist {}
	set bedgelist {}
	set redgelist {}
	set ledgelist {}
	set rmlistt {}
	set rmlistb {}
	set rmlistl {}
	set rmlistr {}
	set newedgelist {}
	set oldedgelist {}
	set fullrmlist {}
	set fulledgelist {}
	
	set oldedgelist [opp_edge $list]
	#set oldedgelist [lsort -uniq [lremove $list $oldedge]]
	#puts "old edges $oldedgelist\n #########\n[llength $oldedgelist]"
	foreach edge3 $oldedgelist {
		#puts $edge3
		#puts $oldedgelist
		set xlist [lsort -uniq -real [lappend xlst [lindex $edge3 0 0]]]
		set ylist [lsort -uniq -real [lappend ylst [lindex $edge3 0 1]]]		
	}

	foreach x $xlist {
		set ylnel {}
		set ylner {}
		foreach edge4 $oldedgelist {
			if {[lindex $edge4 0 0]==$x && \
				[lindex $edge4 2]=="l"} {
					set ylinel [lsort -uniq [lappend ylnel $edge4 ]]
			}
			if {[lindex $edge4 0 0]==$x && \
				[lindex $edge4 2]=="r"} {
					set yliner [lsort -uniq [lappend ylner $edge4 ]]
			}
		}
		set ylinellist [lsort -uniq [lappend ylinellst $ylinel]]
		set ylinerlist [lsort -uniq [lappend ylinerlst $yliner]]
	}
#	puts "edges --- $ylinerlist"
	foreach y $ylist {
		set xlnet {}
		set xlneb {}
		foreach edge5 $oldedgelist {
				if {[lindex $edge5 0 1]==$y && \
					[lindex $edge5 2]=="t"} {
						set xlinet [lsort -uniq [lappend xlnet $edge5]]
				}
				if {[lindex $edge5 0 1]==$y && \
					[lindex $edge5 2]=="b"} {
						set xlineb [lsort -uniq [lappend xlneb $edge5]]
				}
			}
		set xlinetlist [lsort -uniq [lappend xlinetlst $xlinet]]
		set xlineblist [lsort -uniq [lappend xlineblst $xlineb]]
	}	
   #puts "\n##########\nbottom	$xlineblist\n##########\n"
   #puts "\n##########\ntop 	$xlinetlist\n##########\n"
   #puts "\n##########\nleft 	$ylinellist\n##########\n"
   #puts "\n##########\nright	$ylinerlist\n##########\n"	
   #

	foreach xlinet $xlinetlist {
		set sortxline [lsort -index {0 0} -real $xlinet]
		set n [llength $sortxline]
		#puts "asdasdasdasd $sortxline"
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set tedge1 [lindex $sortxline $i]
				set tedge2 [lindex $sortxline $i+1]
				if {[lindex $tedge1 1 0]>=[lindex $tedge2 0 0] } {
						set tedge [minus_edge_same $tedge1 $tedge2]
						#puts "\n\nqweqweqwe \n$tedge1 --- $tedge2\n qweqweqwqwe\n\n"
						#set tedgelist [lsort -uniq [lappend tedgelst $tedge1 $tedge2]]
						set tedgelist  [lsort -uniq [lappend tedgelst $tedge]]
						#puts "$tedgelist created list"
						lappend rmlistt $tedge1 $tedge2
						set l 2
						} elseif {[lindex $tedge1 1 0]<[lindex $tedge2 0 0] && \
								  [lindex $tedge1 1 0]<[lindex $tedge2 1 0]} {
							set tedgelist [lsort -uniq [lappend tedgelst "\{$tedge1\}" "\{$tedge2\}"]]
							#puts "$tedgelist inherit list"
						}
					}	
			} elseif {$n==1} {
				set tedgelist [lappend tedgelst $sortxline]
				#puts "$tedgelist uniq list"
			}
	}
	foreach xlineb $xlineblist {
		set sortxline [lsort -index {0 0} -real $xlineb]
		set n [llength $sortxline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set bedge1 [lindex $sortxline $i]
				set bedge2 [lindex $sortxline $i+1]
				if {[lindex $bedge1 1 0]>=[lindex $bedge2 0 0] } {
					set bedge [minus_edge_same $bedge1 $bedge2]
					set bedgelist [lsort -uniq [lappend bedgelst $bedge]]
					lappend rmlistb $bedge1 $bedge2
					set m 2
					} elseif {[lindex $bedge1 1 0]<[lindex $bedge2 0 0] && \
							  [lindex $bedge1 1 0]<[lindex $bedge2 1 0]} {
								  set bedgelist [lsort -uniq [lappend bedgelst "\{$bedge1\}" "\{$bedge2\}"]]
					}
				}	
			} elseif {$n==1} {
				set  bedgelist [lappend bedgelst $sortxline]
				#puts "$bedgelist uniq list"
			}
	}
		
	foreach yliner $ylinerlist {
		set sortyline [lsort -index {0 1} -real $yliner]
		set n [llength $sortyline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set redge1 [lindex $sortyline $i]
				set redge2 [lindex $sortyline $i+1]
				if {[lindex $redge1 1 1]>=[lindex $redge2 0 1]} {
					set redge [minus_edge_same $redge1 $redge2]
					set redgelist [lsort -uniq [lappend redgelst $redge]]
					lappend rmlistr $redge1 $redge2
					set k 2
					} elseif {[lindex $redge1 1 1]<[lindex $redge2 0 1] && \
							  [lindex $redge1 1 1]<[lindex $redge2 1 1]} {
						set redgelist [lsort -uniq [lappend redgelst "\{$redge1\}" "\{$redge2\}" ]]
					}
				}	
			} elseif {$n==1} {
				set  redgelist [lappend redgelst $sortyline]
				#puts "$redgelist unqi edge edge"
			
			}
	}
	foreach ylinel $ylinellist {
		set sortyline [lsort -index {0 1} -real $ylinel]
		set n [llength $sortyline]
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set ledge1 [lindex $sortyline $i]
				set ledge2 [lindex $sortyline $i+1]
				if {[lindex $ledge1 1 1]>=[lindex $ledge2 0 1] } {
					set ledge [minus_edge_same $ledge1 $ledge2]
					set ledgelist [lsort -uniq [lappend ledgelst $ledge]]
					lappend rmlistl $ledge1 $ledge2
					set e 2
					} elseif {[lindex $ledge1 1 1]<[lindex $ledge2 0 1] && \
							  [lindex $ledge1 1 1]<[lindex $ledge2 1 1]} {
								  set ledgelist [lsort -uniq [lappend ledgelst "\{$ledge1\}" "\{$ledge2\}"]]
					}
				}	
			} elseif {$n==1} {
				set  ledgelist [lappend ledgelst $sortyline]
			}
	}
	set fulledgelist [join [lsort -u [concat {*}[lappend filledgelst $ledgelist $redgelist $tedgelist $bedgelist]]]]
	set fullrmlist   [lsort -u [concat {*}[lappend fullrmlst $rmlistt $rmlistb $rmlistl $rmlistr]]]
	
	
	set newlist [opp_edge [lsort -uniq [lremove $fulledgelist $fullrmlist]]]
    
	
    #puts "\n newlist ------- newlist \n$newlist\n#########\n[llength $newlist]\n##########"
	set nlist [lsort -u -real [lappend nlst $l $m $e $k]]
	#puts "nliiist $nlist"
	set n [lindex $nlist end]
	if {$n==2} {
		set edge [minimum_edge_same $newlist]
		#puts ">>>>>>$edge"
		} else {
			set newlist [lsort -uniq [lsort -real -index {0 0} $list]]
		#	puts "maximum list $newlist"
			return $newlist
	}
	
}


#############################################################################
#############################################################################
proc minimum_edge {list} \
{
	set xedge {}
	set xedgelist {}
	set yedge {}
	set yedgelst {}
	set yedgelist {}
	set l 1
	set rmlist {}
	set list [opp_edge $list]
	foreach edge0 $list {
		#puts $edge0
		set xlist [lsort -uniq  [lappend xlst [lindex $edge0 0 0]]]
		set ylist [lsort -uniq  [lappend ylst [lindex $edge0 0 1]]]
	}
	#puts $xlist	
	foreach x $xlist {
		set xedgelst {}
		foreach edge1 $list {
			if {[lindex $edge1 0 0]==$x && \
				[lindex $edge1 2]=="l" || \
				[lindex $edge1 0 0]==$x && \
				[lindex $edge1 2]=="r"} {
					#puts "qweqwe $edge1"
					set xedge [list [lsort -uniq [lappend xedgelst $edge1]]]
			}		
		}
		set fullxedge [join [lsort -u [lappend xedgelist $xedge]]]
	}
	
	foreach y $ylist {
		set yedgelst {}
		foreach edge1 $list {
			if {[lindex $edge1 0 1]==$y && \
				[lindex $edge1 2]=="t" || \
				[lindex $edge1 0 1]==$y && \
				[lindex $edge1 2]=="b"} {
					#puts "qweqwe $edge1"
					set yedge [list [lsort -uniq [lappend yedgelst $edge1]]]
			}
		}
		set fullyedge [join [lsort -u [lappend yedgelist $yedge]]]
	}
	set fulledgelist [list $fullxedge $fullyedge]
	set j 1
	set newedgelist {}
	#puts $fulledgelist	
	foreach linex $fullxedge {
		set sortlinex [lsort -real -index {0 1} $linex]
		set n [llength $sortlinex]
		#puts $n
	#	puts "\n$sortlinex\n"
		if {$n>=2} {
			for {set i 0} {$i < $n-1} {incr i} {
				set edge1 [lindex $sortlinex $i]
				set edge2 [lindex $sortlinex $i+1]
				if {[lindex $edge1 2]!=[lindex $edge2 2]} {
					if {[lindex $edge1 0 1]==[lindex $edge2 0 1] && \
						[lindex $edge1 1 1]< [lindex $edge2 1 1] || \
						[lindex $edge1 0 1]< [lindex $edge2 0 1] && \
						[lindex $edge1 1 1]==[lindex $edge2 1 1] || \
						[lindex $edge1 0 1]< [lindex $edge2 0 1] && \
						[lindex $edge1 1 1]> [lindex $edge2 0 1]} {
							set newedgepair [minus_edge $edge1 $edge2]
							set newedgelist [lsort -u [lappend newedgelst $newedgepair]]
							#puts $newedgelist
							set j 2
					} elseif {[lindex $edge1 1 1]< [lindex $edge2 0 1]} {
						#puts "$edge1 $edge2 \tqweqweqweqwe "
						
					}
					} elseif {[lindex $edge1 2]==[lindex $edge2 2]} {
						if {[lindex $edge1 0 1] < [lindex $edge2 0 1] && \
							[lindex $edge1 1 1] > [lindex $edge2 0 1]} {
							#puts "$edge1 $edge2 rfvrfvrfv"
								set newedge "\{\{[lindex $edge2 0 0] [lindex $edge2 0 1]\} \{[lindex $edge1 1 0] [lindex $edge1 1 1]\} [lindex $edge1 2]\}"
								#set newedge [minus_edge_same $edge1 $edge2]
								set newedgelist [lsort -u [lappend newedgelst $newedge]]
						}
					}
			}
			} elseif {$n==1} {
				set  newedgelist [lsort -u [lappend newedgelst $sortlinex]]
				#puts $newedgelist
			}
	}

	foreach liney $fullyedge {
		set sortliney [lsort -real -index {0 0} $liney]
		set m [llength $sortliney]
		if {$m>=2} {
			for {set i 0} {$i < $m-1} {incr i} {
				set edge1 [lindex $sortliney $i]
				set edge2 [lindex $sortliney $i+1]
				if {[lindex $edge1 2]!=[lindex $edge2 2]} {
					if {[lindex $edge1 0 0]==[lindex $edge2 0 0] && \
						[lindex $edge1 1 0]< [lindex $edge2 1 0] || \
						[lindex $edge1 0 0]< [lindex $edge2 0 0] && \
						[lindex $edge1 1 0]==[lindex $edge2 1 0] || \
						[lindex $edge1 0 0]< [lindex $edge2 0 0] && \
						[lindex $edge1 1 0]> [lindex $edge2 0 0]} {
							#puts "$edge1 $edge2"
							set newedgepair [minus_edge $edge1 $edge2]
							set newedgelist [lsort -u [lappend newedgelst $newedgepair]]
							#puts $newedgepair
							set j 2
							} elseif {[lindex $edge1 1 0]<[lindex $edge2 0 0]} {
								#puts "$edge1 $edge2 asd asd"
							}
					} elseif {[lindex $edge1 2]==[lindex $edge2 2]} {
						if {[lindex $edge1 0 0] < [lindex $edge2 0 0] && \
							[lindex $edge1 1 0] > [lindex $edge2 0 0]} {
							#puts "$edge1 $edge2"
								set newedge "\{\{[lindex $edge2 0 0] [lindex $edge2 0 1]\} \{[lindex $edge1 1 0] [lindex $edge2 0 1]\} [lindex $edge2 2]\}"
								#set newedge [minus_edge_same $edge1 $edge2]
								set newedgelist [lsort -u [lappend newedgelst $newedge]]
						}
					#puts "$edge1 $edge2 brlm brlm"
					}
			}
			} elseif {$m==1} {
				set newedgelist [lsort -u [lappend newedgelst $sortliney]]
				#puts $newedgelist
			}
		#puts "\n$sortliney\n"
	}
	#puts $newedgelist
	#foreach line $fulledgelist {
	#	set n [llength $line]
		#puts "\nline----- $list\n"
	#	if {$n>=2} {
	#		foreach edge2 $line {
	#			foreach edge3 $line {
	#				if {[lindex $edge2 1 1]> [lindex $edge3 0 1] && \
	#					[lindex $edge2 0 1]< [lindex $edge3 0 1] && \
	#					[lindex $edge2 1 1]<=[lindex $edge3 1 1] || \
	#					[lindex $edge2 1 0]> [lindex $edge3 0 0] && \
	#					[lindex $edge2 0 0]< [lindex $edge3 0 0] && \
	#					[lindex $edge2 1 0]<=[lindex $edge3 1 0] || \
	#					[lindex $edge2 1 1]> [lindex $edge3 0 1] && \
	#					[lindex $edge2 0 1]<=[lindex $edge3 0 1] && \
	#					[lindex $edge2 1 1]< [lindex $edge3 1 1] || \
	#					[lindex $edge2 1 0]> [lindex $edge3 0 0] && \
	#					[lindex $edge2 0 0]<=[lindex $edge3 0 0] && \
	#					[lindex $edge2 1 0]< [lindex $edge3 1 0]} {
	#						if {[lindex $edge2 2]!=[lindex $edge3 2]} {
	#							set newedgepair [minus_edge $edge2 $edge3]
	#							#puts "\n##<<<<<<<<<<##################>>>>>>>>>>>>>\n if case $edge2 ------ $edge3\n"
	#							set newedgelist [lsort -uniq [join [lappend newedgelst $newedgepair]]]
	#							#puts "$newedgepair\n"
	#							#puts "$newedgelist"
	#							set rmlist [lappend rmlst $edge2 $edge3]
	#							#puts "\nrmlist $rmlist\n<<<<<<<<<<#####################>>>>>>>##\n\n"
	#							set l 2 
	#							}							
	#						} elseif {[lindex $edge2 1 1]<[lindex $edge3 0 1] && \
	#								  [lindex $edge2 1 1]<[lindex $edge3 1 1] || \
	#								  [lindex $edge2 1 0]<[lindex $edge3 0 0] && \
	#								  [lindex $edge2 1 0]<[lindex $edge3 1 0]} {
	#									  #puts "\nelse case $edge2 ---- $edge3"
	#									  set newedgelist [lsort -u [join [lappend newedgelst "\{$edge2\}" "\{$edge3\}"]]]
	#									  #puts "new edgelist $newedgelist\n"
	#					}
	#				}
	#			}
	#		} elseif {$n==1} {
	#			set newedgelist [join [lappend newedgelst $line]]
	#			#puts "n1 == 1 case $newedgelist\n"
	#		}
	#}
	#puts "\n\n>>>>>>>>>>>------ oldedgelist ------------ <<<<<<<<<<<<\n$list\n[llength $list]\n<<<<<<<<<<<<--------------->>>>>>>>>>>\n"
	#puts ">>>>>>>>>>>------ newedgelist ------------ <<<<<<<<<<<<\
	\n$newedgelist\n[llength $newedgelist]\n<<<<<<<<<<<<--------------->>>>>>>>>>>\n\n"
	#set newlist [lremove [lsort -u $newedgelist ] $list ]
	#puts "#####\n$newlist\n######\n"
	#set n [lindex [lappend llist $l] end]
#	puts $n
	set newedgelist [join $newedgelist]
	#puts ">>>>>>>>>>>------ new edgelist ------------ <<<<<<<<<<<<\
		\n$newedgelist\n[llength $newedgelist]\n<<<<<<<<<<<<--------------->>>>>>>>>>>\n\n"
	
	if {$j==2} {
		set edge [minimum_edge $newedgelist]
		#puts $edge
		} else {
			return $newedgelist
	}
}
#############################################################################
#############################################################################


proc final_minedge {list} \
{
	set fulledgelist [edges $list]
	#puts $fulledgelist
	set maxedge [maximum_edge $fulledgelist]
	#puts "\n##########\n$maxedge\n############\n"
	set minedge [minimum_edge $maxedge]
	#puts $minedge
	return $minedge
}

#############################################################################
#############################################################################

#set qweqwe [final_minedge $list]
