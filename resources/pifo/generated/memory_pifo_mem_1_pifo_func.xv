module memory_pifo_mem_1_pifo_func(clk,
rst,
pifo_func_write,
pifo_func_wr_adr,
pifo_func_din,
pifo_func_read,
pifo_func_rd_adr,
pifo_func_rd_dout);

parameter NUMRPRT = 1;
parameter NUMWPRT = 1;
parameter NUMADDR = 32;
parameter BITDATA = 16;
localparam BITADDR = $clog2(NUMADDR);



input  clk;
input  rst;
input [NUMWPRT-1:0] pifo_func_write;
input [BITADDR*NUMWPRT-1:0] pifo_func_wr_adr;
input [BITDATA*NUMWPRT-1:0] pifo_func_din;
input [NUMRPRT-1:0] pifo_func_read;
input [BITADDR*NUMRPRT-1:0] pifo_func_rd_adr;
output reg [BITDATA*NUMRPRT-1:0] pifo_func_rd_dout;



wire [127:0] din [0:0];
wire [127:0] rd_dout [0:0];
wire [9:0] wr_adr [0:0];
wire [9:0] rd_adr [0:0];





assign din[0] = pifo_func_din;
assign pifo_func_rd_dout = rd_dout[0];
assign wr_adr[0] = pifo_func_wr_adr;
assign rd_adr[0] = pifo_func_rd_adr;

generate if (1) begin: flpflop_mem

        

memoir_ff_mem# (.NUMWPRT(NUMWPRT),
	.NUMRPRT(NUMRPRT),
	.BITADDR(BITADDR),
	.NUMADDR(NUMADDR),
	.WIDTH(BITDATA),
	.FLOPOUT(0)) 
memory_pifo_func_memoir_ff_mem_inst (.write(pifo_func_write),
	.wr_adr(wr_adr),
	.din(din),
	.read(pifo_func_read),
	.rd_adr(rd_adr),
	.rd_dout(rd_dout),
	.clk(clk),
	.rst(rst));

end else begin: nflpflop_mem
                // TODO Stitch memogen
        //memoir_mem #()
        //mem_sm_mem();
end
endgenerate

endmodule