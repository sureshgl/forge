Rnaxi(StList)::=<<
<StList:{item |<item><\n>}>
>>

rnaxiStartModule(module_name,ports)::=<<
module <module_name>(<trunc(ports):{item |<item>,}><last(ports):{item |<item>}>);

>>

rnaxiEndmodule(comments)::=<<

endmodule <comments>
>>

ModuleInstantiationsInNaxiTop()::=<<
rnaxi_slv   u_rnaxi_slv();

//rnaxi_slv_regs u_rnaxi_slv_regs();

rnaxi_reg_wrap u_rnaxi_reg_wrap();

rnaxi_slv_addr_dec  u_rnaxi_slv_addr_dec();
>>

RegisterInputReg(reg_name,reg_wr_en_range)::=<<
input <reg_wr_en_range> <reg_name>_rdata;
>>

RnaxiSlvAddrDecInputReg(reg_name,reg_wr_en_range)::=<<
input <reg_wr_en_range> <reg_name>_rdata;
>>

RnaxiSlvAddrDecOutputReg(reg_name,reg_wr_en_range)::=<<
output reg <reg_wr_en_range> <reg_name>_wr_en;
output reg <reg_wr_en_range> <reg_name>_rd_en;
>>

RegisterOutputReg(reg_name,reg_wr_en_range)::=<<
output reg <reg_wr_en_range> <reg_name>_wr_en;
>>

NaxiTopSlvOutputReg(reg_name,reg_wen_range,reg_rdata_range)::=<<
output reg <reg_rdata_range> <reg_name>_rdata;
output reg <reg_wen_range> <reg_name>_wen;
>>

NaxiTopSlvInputReg(reg_name,reg_wr_en_range)::=<<
input <reg_wr_en_range> <reg_name>_wr_en;
>>

NaxiSlvRegsOutputReg(reg_name,reg_wen_range,reg_rdata_range)::=<<
output reg <reg_rdata_range> <reg_name>_rdata;
output reg <reg_wen_range> <reg_name>_wen;
>>

NaxiSlvRegsOutputAck(ack_range)::=<<
output reg [<ack_range>:0] ack_out; 
>>

NaxiSlvAddrDecParameter()::=<<
   parameter REQ_TYPE_WIDTH  = 2;
   parameter REQ_ATTR_WIDTH  = 3;
   parameter REQ_SIZE_WIDTH  = 6;
   parameter REQ_DATA_WIDTH  = 32;
   input [REQ_SIZE_WIDTH:0] req_size;
   output reg [2047:0] reg_rd_data;
>>

NaxiSlvRegsInputReg(reg_name,reg_wr_en_range)::=<<
input <reg_wr_en_range> <reg_name>_wr_en;
>>

NaxiSlvRegsFixedPorts(rd_en_range)::=<<
input [2047:0] reg_data;
input [<rd_en_range>:0] rd_en;
>>

naxiDefaultInputOuputPorts(rd_en_range)::=<<
// fixed ports
input wr_req_rcvd;
input [31:0] req_addr;
input rd_req_rcvd;
input load_rd_data;
output reg [2047:0] reg_data;
input [2047:0] reg_wr_data;
output <rd_en_range> rd_en;
>>

naxiDecoderAssign(beats,beatWidth,beatAddrWidth,req_address,isAddrSizeGtZero,address_size,register)::=<<
<register:{item|
  
  assign <item>_wr_en[<beats>:0] = <item>_wr_en && (req_addr == 32'<req_address>) ? <beatWidth>'h<beatAddrWidth> : <beatWidth>'h0 ;
  assign <item>_wr_data<if(isAddrSizeGtZero)>[<address_size>-1:0]<endif> = (|<register>_wr_en) ? <item>_wr_data<if(isAddrSizeGtZero)>[<address_size>-1:0]<endif> : <address_size>'h0;}>
>>

naxiDecodeResetAssign(register,beatWidth)::=<<
<register>_wr_en = <beatWidth>'h0;
>>

naxiReadDecodeResetAssign(max_reg_size,rd_en_range,rd_en_size)::=<<
		reg_rd_data[<max_reg_size>-1:0] = <max_reg_size>'h0;
		rd_en[<rd_en_range>]  = <rd_en_size>'h0;
>>

naxiDecoderCasedeclarationStart(condition)::=<<
case(<condition>)
>>

naxiNewLine()::=<<

>>

DefaultPorts()::=<<
input clk;
input rst;
>>

naxiDecoderCasedeclarationEnd()::=<<
endcase // Case end
>>


naxiDecoderCaseLogic(reg_name, address,reg_range,beatWidth,beatAddrWidth, req_addr_size,dataWidth,beatAddrWidthhex,beatWidthhex)::=<<
	33'h1_<address>: begin
       <reg_name>_wr_en[<reg_range>] = <beatWidth>'h<beatAddrWidthhex> >\>(<req_addr_size>'h<beatWidthhex>-req_size[<req_addr_size>-1:0]); 
       reg_data = reg_wr_data \<\< <dataWidth>;
    end
>>

naxiDecoderCaseReadLogic(reg_name,address,max_reg_size,beatWidth,beatAddrWidth,rd_data,reg_addr_range,rd_en_range)::=<<
	33'h1_<address>: begin
       reg_rd_data[<max_reg_size>-1:0] = load_rd_data ? {<rd_data>'h0,<reg_name>_rdata <reg_addr_range>} : <max_reg_size>'h0;
       rd_en[<rd_en_range>]  = load_rd_data ? <beatWidth>'h0 : <beatWidth>'h<beatAddrWidth>;
    end
>>

naxiDefaultCaseLogic(logic)::=<<
	default: begin
		<logic>
	end>>
	
naxiDefaultReadCaseLogic(max_reg_size,rd_en_range,rd_en_size)::=<<
	default: begin
		default: begin
           reg_rd_data[<max_reg_size>-1:0] = <max_reg_size>'h0;
           rd_en[<rd_en_range>]  = <rd_en_size>'h0;
        end
		
	end>>	

naxiDecoderAlwaysLogicStart()::=<<
always @(*) begin
>>

naxiDecoderAlwaysLogicEnd()::=<<
end
>>

naxiRegInstantiations(reg_name,reg_width,reg_data_width,reg_en_range,cfg_ack_out)::=<<
rnaxi_regs #(.REG_WIDTH(<reg_width>), .REG_DATA_WIDTH(<reg_data_width>)) 
               <reg_name>_inst(
                .clk(clk),
                .rst(rst),
                .reg_wr_en(<reg_name>_wr_en),
                .reg_rd_en(|rd_en[<reg_en_range>]),
                .reg_wr_data(reg_data[<reg_data_width>-1:0]),
                .reg_out(<reg_name>_rdata),
                .reg_wen(<reg_name>_wen),
                .reg_ren(),
                .ack_req(1'b0),
                .ack_out(ack_out[<cfg_ack_out>]),
                .ack_in(1'b0)
              );
>>

RnaxiSlvTopWireDeclarations(wire_map)::=<<
<wire_map.keys:{k | wire <wire_map.(k)> <k>;}; separator="\n">
>>

naxiSlvTopFixedPorts()::=<<

   parameter REQ_TYPE_WIDTH  = 2;
   parameter REQ_ATTR_WIDTH  = 3;
   parameter REQ_SIZE_WIDTH  = 6;
   parameter REQ_DATA_WIDTH  = 32;
   parameter SLV_START_ADDR  = 32'h0000_0000;
   parameter SLV_END_ADDR  = 32'hFFFF_FFFF;
   parameter SLV_INTR_BIT  = 31;

   input clk;
   input rst;
   
   //up stream inputs
   input u_req_valid;
   input u_req_intr;
   input [REQ_TYPE_WIDTH-1:0] u_req_type;
   input [REQ_ATTR_WIDTH-1:0] u_req_attr;
   input [REQ_SIZE_WIDTH-1:0] u_req_size;
   input [REQ_DATA_WIDTH-1:0] u_req_data;
   //down stream inputs
   input  d_req_stall;

   //up stream outputs
   output reg u_req_stall;

   //down stream outputs
   output reg d_req_valid;
   output reg d_req_intr;
   output reg [REQ_TYPE_WIDTH-1:0] d_req_type;
   output reg [REQ_ATTR_WIDTH-1:0] d_req_attr;
   output reg [REQ_SIZE_WIDTH-1:0] d_req_size;
   output reg [REQ_DATA_WIDTH-1:0] d_req_data;
>>


RNaxiSlv(ackRange)::=<<

module rnaxi_slv 
  (
    clk,
    rst,
    u_req_valid, 
    u_req_type,
    u_req_attr,
    u_req_size,
    u_req_data,
    u_req_intr,
    u_req_stall,
    d_req_valid, 
    d_req_type,
    d_req_attr,
    d_req_size,
    d_req_data,
    d_req_intr,
    d_req_stall,
    wr_req_rcvd,
    rd_req_rcvd,
    load_rd_data,
    req_addr,
    reg_wr_data,
    reg_rd_data,
    req_size,
    ack_out

   );

   parameter REQ_TYPE_WIDTH  = 2;
   parameter REQ_ATTR_WIDTH  = 3;
   parameter REQ_SIZE_WIDTH  = 6;
   parameter REQ_DATA_WIDTH  = 32;
   parameter SLV_START_ADDR  = 32'h0000_0000;
   parameter SLV_END_ADDR  = 32'hFFFF_FFFF;
   parameter SLV_INTR_BIT  = 31;

   input clk;
   input rst;
   //up stream inputs
   input u_req_valid; 
   input u_req_intr;
   input [REQ_TYPE_WIDTH-1:0] u_req_type;
   input [REQ_ATTR_WIDTH-1:0] u_req_attr;
   input [REQ_SIZE_WIDTH-1:0] u_req_size;
   input [REQ_DATA_WIDTH-1:0] u_req_data;
   //down stream inputs
   input  d_req_stall;

   //up stream outputs
   output reg u_req_stall;
   
   //down stream outputs
   output reg d_req_valid; 
   output reg d_req_intr;
   output reg [REQ_TYPE_WIDTH-1:0] d_req_type;
   output reg [REQ_ATTR_WIDTH-1:0] d_req_attr;
   output reg [REQ_SIZE_WIDTH-1:0] d_req_size;
   output reg [REQ_DATA_WIDTH-1:0] d_req_data;
   output reg wr_req_rcvd;
   output reg rd_req_rcvd;
   output reg load_rd_data;
   output reg [REQ_DATA_WIDTH-1:0] req_addr;
   output reg [2047:0] reg_wr_data;
   input reg [2047:0] reg_rd_data;
   output reg [REQ_SIZE_WIDTH:0] req_size;
   input [<ackRange>:0]ack_out;


   localparam S_RNAXI_IDLE           = 3'd0;
   localparam S_RNAXI_SEND_RES       = 3'd1;
   localparam S_RNAXI_BEAT           = 3'd2;
   localparam S_RNAXI_BYPASS         = 3'd3;
   localparam S_RNAXI_WAIT_ACK       = 3'd4;
   
   reg [2:0] s_rnaxi_nstate;
   reg [2:0] s_rnaxi_cstate;
   reg [2047:0] shft_reg;
   reg [REQ_SIZE_WIDTH:0] beats_sent;
   reg [REQ_ATTR_WIDTH-1:0] req_attr;
   reg [REQ_TYPE_WIDTH-1:0] req_type;
   wire nstate_idle;
   wire nstate_send_res;
   wire nstate_beat;
   wire nstate_wait_ack;
   wire cstate_idle;
   wire cstate_send_res;
   wire cstate_beat;
   wire cstate_wait_ack;
   wire all_beats_sent;
   wire own_space;


   assign own_space = (SLV_START_ADDR \<= u_req_data[REQ_DATA_WIDTH-1:0]) && (u_req_data[REQ_DATA_WIDTH-1:0] \<= SLV_END_ADDR);
 
   always @(*) begin
      case (s_rnaxi_cstate)
      
        S_RNAXI_IDLE: begin
          if ((u_req_valid && (~own_space)) || (u_req_type == 2'h3)) begin  //Response or Request for other slave
            s_rnaxi_nstate = S_RNAXI_BYPASS;
          end else if(u_req_valid && (u_req_type == 2'h0)) begin //WRITE
            s_rnaxi_nstate = S_RNAXI_BEAT;
          end else if(u_req_valid && (u_req_type == 2'h1)) begin //READ
            s_rnaxi_nstate = S_RNAXI_WAIT_ACK;
          end else if(u_req_valid && (u_req_type == 2'h2)) begin //FLUSH
            s_rnaxi_nstate = S_RNAXI_SEND_RES;
          end else begin
            s_rnaxi_nstate = S_RNAXI_IDLE;
          end
        end 
        S_RNAXI_BEAT: begin
          if(u_req_valid && u_req_attr[1]) begin
            s_rnaxi_nstate = S_RNAXI_WAIT_ACK;
          end else begin
            s_rnaxi_nstate = S_RNAXI_BEAT;
          end
        end
        S_RNAXI_BYPASS: begin
        end
        S_RNAXI_WAIT_ACK: begin
          if(|ack_out) begin
            s_rnaxi_nstate = S_RNAXI_SEND_RES;
          end else begin
            s_rnaxi_nstate = S_RNAXI_WAIT_ACK;
          end
        end
        S_RNAXI_SEND_RES: begin
          if(all_beats_sent) begin
            s_rnaxi_nstate = S_RNAXI_IDLE;
          end else begin
            s_rnaxi_nstate = S_RNAXI_SEND_RES;
          end 
        end 
        default : begin 
          s_rnaxi_nstate = S_RNAXI_IDLE;
        end
      endcase
   end //always_end

   always @(posedge clk or posedge rst) begin
     if (rst) begin 
        s_rnaxi_cstate \<= S_RNAXI_IDLE;
     end else begin
        s_rnaxi_cstate \<= s_rnaxi_nstate;
     end
   end
  
   always @(posedge clk or posedge rst) begin
     if (rst) begin
       req_size \<= {REQ_SIZE_WIDTH{1'b0}};
       req_type \<= {REQ_TYPE_WIDTH{1'b0}};
       req_attr \<= {REQ_ATTR_WIDTH{1'b0}};
       req_addr \<= {REQ_DATA_WIDTH{1'b0}};
     end else if(cstate_idle && (nstate_beat || nstate_wait_ack || nstate_send_res)) begin
       req_size \<= (~|u_req_size) ? 7'h40 : {1'b0,u_req_size[REQ_SIZE_WIDTH-1:0]};
       req_type \<= u_req_type[REQ_TYPE_WIDTH-1:0];
       req_attr \<= u_req_attr[REQ_ATTR_WIDTH-1:0];
       req_addr \<= u_req_data[REQ_DATA_WIDTH-1:0];
     end
   end
  
   always @(posedge clk or posedge rst) begin
     if (rst) begin
       reg_wr_data \<= 2048'h0;
     end else if(cstate_idle) begin
       reg_wr_data \<= 2048'h0;
    end else if(nstate_wait_ack && cstate_beat) begin
       reg_wr_data[2047:0] = ({u_req_data,reg_wr_data[2047:32]}) \>> (12'h800-((req_size[REQ_SIZE_WIDTH:0]) \<\< 5));
     end else if(cstate_beat) begin
       reg_wr_data \<= {u_req_data,reg_wr_data[2047:32]};
     end 
   end

   always @(posedge clk or posedge rst) begin
     if (rst) begin
       beats_sent \<= {(REQ_SIZE_WIDTH+1){1'b0}};
     end else if(cstate_send_res && nstate_idle && (~d_req_stall)) begin
       beats_sent \<= {(REQ_SIZE_WIDTH+1){1'b0}};
     end else if(cstate_send_res &&(~d_req_stall)) begin
       beats_sent \<= beats_sent + 1;
     end else if(cstate_send_res && d_req_stall) begin
       beats_sent \<= beats_sent;
     end else begin
       beats_sent \<= {(REQ_SIZE_WIDTH+1){1'b0}};
     end 
   end

  assign all_beats_sent = (beats_sent == (req_size-1)) && (~d_req_stall);

  assign nstate_idle     =  (s_rnaxi_nstate == S_RNAXI_IDLE);
  assign nstate_send_res =  (s_rnaxi_nstate == S_RNAXI_SEND_RES);
  assign nstate_wait_ack =  (s_rnaxi_nstate == S_RNAXI_WAIT_ACK);
  assign nstate_beat     =  (s_rnaxi_nstate == S_RNAXI_BEAT);
  
  assign cstate_idle     =  (s_rnaxi_cstate == S_RNAXI_IDLE);
  assign cstate_send_res =  (s_rnaxi_cstate == S_RNAXI_SEND_RES);
  assign cstate_wait_ack =  (s_rnaxi_cstate == S_RNAXI_WAIT_ACK);
  assign cstate_beat     =  (s_rnaxi_cstate == S_RNAXI_BEAT);


  always @(posedge clk or posedge rst) begin
    if(rst) begin
      wr_req_rcvd \<= 1'b0;
    end else if(nstate_wait_ack && cstate_beat && (req_type == 3'h0)) begin
      wr_req_rcvd \<= 1'b1;
    end else begin
      wr_req_rcvd \<= 1'b0;
    end
  end
  
  always @(posedge clk or posedge rst) begin
    if(rst) begin
      rd_req_rcvd \<= 1'b0;
    end else if(cstate_idle && nstate_wait_ack) begin
      rd_req_rcvd \<= 1'b1;
    end else begin
      rd_req_rcvd \<= 1'b0;
    end
  end
  
  always @(posedge clk or posedge rst) begin
    if(rst) begin
      u_req_stall \<= 1'b0;
     end else if(cstate_send_res && d_req_stall) begin //stall only when request is asserted //REVISIT
      u_req_stall \<= 1'b1;
    end else if(cstate_send_res) begin
      u_req_stall \<= 1'b0; //unstall as long as it is in read and no new request
    end else if(cstate_idle) begin
      u_req_stall \<= 1'b0;
    end
  end

  assign load_rd_data = cstate_wait_ack && nstate_send_res;

  always @(posedge clk or posedge rst) begin
    if(rst) begin
      shft_reg \<= 2048'h0;
    end else if(load_rd_data) begin
      if(req_type == 3'h1) begin //READ data
         shft_reg \<= reg_rd_data[2047:0]; 
      end else begin //WRITE res and RES packets
      end
    end else if(cstate_send_res && nstate_idle && (~d_req_stall)) begin
      shft_reg \<= 2048'h0; 
    end else if(cstate_send_res && (~d_req_stall)) begin
      shft_reg \<= {32'h0,shft_reg[2047:32]};
    end else if(cstate_send_res) begin
      shft_reg \<= shft_reg[2047:0];
    end else begin
      shft_reg \<= 2048'h0;
    end
  end

  assign d_req_data[REQ_DATA_WIDTH-1:0] = shft_reg[REQ_DATA_WIDTH-1:0];

endmodule // rnaxi_slv

>>
